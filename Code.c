#include "F28x_Project.h"
void SysControl(void);
void Adc(void);
void Timer0(void);
void GpioInit(void);
__interrupt void Adcisr(void);
int i,j;
void main(void)
{
 DINT;//disable the interrupt
 SysControl();//function call
 Timer0();
 Adc();
 GpioInit();
 EALLOW;
 PieCtrlRegs.PIECTRL.bit.ENPIE=1;//enable the interrupt in PIE stage
 PieCtrlRegs.PIEIER1.bit.INTx1=1;//enable the ADC interrupt at PIE level
 PieVectTable.ADCA1_INT= &Adcisr;//write the address of the function,peripheral
level
 PieCtrlRegs.PIEACK.bit.ACK1=1;//clear the acknowledge bit
 EDIS;
 IER=0x0001;//enable the interrupt at CPU stage
 EINT;//enable the global interrupt
 while(1);
}
void SysControl(void)
{
 EALLOW;
 ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL=00;//select the clock source
 ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN=0;
 for(i=0;i<=120;i++);
 ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV=0;//clear this bit to ensure
fastest PLL configuration
 for(i=0;i<5;i++)
 { ClkCfgRegs.SYSPLLCTL1.bit.PLLEN=0;//lock PLL
 ClkCfgRegs.SYSPLLMULT.bit.FMULT=00;//no fractional mult

 ClkCfgRegs.SYSPLLMULT.bit.IMULT=16;//10Mhz PLL raw clock
 while(ClkCfgRegs.SYSPLLSTS.bit.LOCKS!=1);
 }
 ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV=1;
 ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN=1;
 ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV=0;
 ClkCfgRegs.LOSPCP.bit.LSPCLKDIV=1;
 //set the low speed clock
 EDIS;
}
void Timer0(void)
{ EALLOW;
 CpuSysRegs.PCLKCR0.bit.CPUTIMER0=1;//turn on the Timer0 module clock
 CpuTimer0Regs.TCR.bit.TSS=1;//stop the timer so as to set the initial condition
 CpuTimer0Regs.TPR.bit.PSC=100;//set the prescalar so as to obtain lesser frequencies
generated by system clock
 CpuTimer0Regs.PRD.all=50000;//set the period register to desired period
 CpuTimer0Regs.TCR.bit.TIF=1;//clear overflow flag
 CpuTimer0Regs.TCR.bit.TIE=1;//enable the interrupt
 CpuTimer0Regs.TCR.bit.FREE=1;//set to free run mode
 CpuTimer0Regs.TCR.bit.TRB=1;//reload register used to load the any changed value
 CpuTimer0Regs.TCR.bit.TSS=0;//start the timer since all the initial values are set
 EDIS;
}
void Adc(void)
{
 EALLOW;
 CpuSysRegs.PCLKCR13.bit.ADC_A=1; //Enable the clock for the ADC
 AdcaRegs.ADCCTL2.bit.PRESCALE=0x03; //Set the ADC clock frequency
 AdcaRegs.ADCCTL2.bit.SIGNALMODE=0;
 AdcaRegs.ADCCTL2.bit.RESOLUTION=0;//Resolution,Signal mode,Ref Hi,Ref
loww
 AdcaRegs.ADCCTL1.bit.ADCPWDNZ=1;//Power up for ADC
 AdcaRegs.ADCSOC0CTL.bit.CHSEL=2;
 AdcaRegs.ADCSOC0CTL.bit.TRIGSEL=01;
 AdcaRegs.ADCSOC0CTL.bit.ACQPS=83;//Setting up SOC's
 AdcaRegs.ADCCTL1.bit.INTPULSEPOS=1;//Interrupt position select(at the end of
conversion there will be interrupt)
 AdcaRegs.ADCINTSEL1N2.bit.INT1SEL=0;//if i have selected more than 1 channel
then here i should put the last channel that i have chosen (which has the highest number)

 AdcaRegs.ADCINTSEL1N2.bit.INT1E=1;//Select and Enable the interrupt
 EDIS;
}
void Adcisr(void)
{
 EALLOW;
 CpuTimer0Regs.TCR.bit.TIF=1;//clear the overflow flag
 j=AdcaResultRegs.ADCRESULT0&0X0FFF;//reading the ADC that is from
peripheral to ADC
 //or
 //int ResulrArray[0]=AdcaResultRegs.ADCRESULT0;
 if(j<1700)
 GpioDataRegs.GPASET.bit.GPIO16=1;
 else if(j>2500)
 GpioDataRegs.GPACLEAR.bit.GPIO16=1;
 AdcaRegs.ADCINTFLGCLR.bit.ADCINT1=1;//ADC interrupt flag to be cleared
 PieCtrlRegs.PIEACK.bit.ACK1=1;//clear the acknowledge bit
 EDIS;
}
void GpioInit(void)
{
 EALLOW;//protected
 GpioCtrlRegs.GPADIR.bit.GPIO16=1;//make GPIO18 as OUTput pin
 GpioCtrlRegs.GPAGMUX2.bit.GPIO16=00;
 GpioCtrlRegs.GPAMUX2.bit.GPIO16=00;
 GpioCtrlRegs.GPAPUD.bit.GPIO16=00;
 EDIS;
}
